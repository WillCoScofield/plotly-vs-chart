import java.text.SimpleDateFormat

boolean pushImageToExternalRegistry = false
boolean promoteImageAsReleaseCandidate = false
boolean promoteImageAsLatest = false
failedStages = ""
skippedStages = ""

openshift.withCluster {
  openshift.withProject {
    script {
      date = new Date()
      env.IMAGE_TAG_DATE_AND_TIME = new SimpleDateFormat("yyyyMMdd").format(date)
      env.NOTIFICATION_DATE_AND_TIME = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss Z").format(date)
    }

    env.CLUSTER = "${openshift.cluster()}"
    env.PROJECT = "${openshift.project()}"
    env.BUILD_CONFIG = "${BUILD_CONFIG_NAME}"

    // Note that below 'GIT_BRANCH' is not the oc source ref but an env var defined under the jenkins build strategy so that it can be overridden when we launch build from other build pipelines; FYI, it's because GIT_BRANCH is set by either the 'Declarative Checkout' or the Git step once executed
    env.GIT_BRANCH_OVERRIDE = GIT_BRANCH
  }
}

// TODO refactor slack notification to a common library to be shared by pipelines
def notifySlack(projectName, pipelineName, startedDateTime, buildResult, failedStages, skippedStages, buildDuration, gitBranch, gitCommit, gitCommitMessage, gitAuthor) {
  jenkinsUrl = JENKINS_URL
  openShiftUrl = OPENSHIFT_URL
  bitBucketRepoUrl = BITBUCKET_REPO_URL
  buildEnvironmentIdentifier = BUILD_ENVIRONMENT_IDENTIFIER ? "(" + BUILD_ENVIRONMENT_IDENTIFIER + ")" : ""

  slackChannel = "#aries-notifications"
  slackUsername = "build notification ${buildEnvironmentIdentifier}"
  gitBranchUrl = "${bitBucketRepoUrl}/commits?until=refs/heads/${gitBranch}"
  gitCommitUrl = "${bitBucketRepoUrl}/commits/${gitCommit}"

  echo "Sending build notification to Slack channel ${slackChannel}"

  buildNotificationText = "Pipeline: *${pipelineName}*, Started: ${startedDateTime}, Duration : ${buildDuration}"
  if ("${BUILD_ENVIRONMENT_IDENTIFIER}" != "") {
    buildNotificationText = "Build Environment: *${BUILD_ENVIRONMENT_IDENTIFIER}*, ${buildNotificationText}"
  }
  if ("${BUILD_CAUSE}" != "") {
    buildNotificationText = "_*(${BUILD_CAUSE})*_ ${buildNotificationText}"
  }
  buildNotificationAttachmentPretext = "Branch: <${gitBranchUrl}|${gitBranch}>, Commit: <${gitCommitUrl}|${gitCommit}>, Message: ${gitCommitMessage}, Author: ${gitAuthor}"
  buildNotificationAttachmentFallback = buildNotificationAttachmentPretext

  jenkinsBuildLogUrl = "${jenkinsUrl}/job/${PROJECT}/job/${JOB_BASE_NAME}/${BUILD_NUMBER}/console"
  jenkinsBuildLogUrlText = "View build output"
  jenkinsBlueOceanPipelineUrl = "${jenkinsUrl}/blue/organizations/jenkins/${projectName}%2F${projectName}-${pipelineName}/detail/${projectName}-${pipelineName}/${BUILD_NUMBER}/pipeline"
  jenkinsBlueOceanPipelineUrlText = "View build stages"
  openShiftPipelinesUrl = "${openShiftUrl}/console/project/${projectName}/browse/pipelines/${pipelineName}"
  openShiftPipelinesUrlText = "View build pipeline"

  buildNotificationAttachmentFieldsValue = "<${jenkinsBuildLogUrl}|${jenkinsBuildLogUrlText}>."
  buildNotificationAttachmentFieldsValue = buildNotificationAttachmentFieldsValue + " <${jenkinsBlueOceanPipelineUrl}|${jenkinsBlueOceanPipelineUrlText}>."
  buildNotificationAttachmentFieldsValue = buildNotificationAttachmentFieldsValue + " <${openShiftPipelinesUrl}|${openShiftPipelinesUrlText}>."
  buildNotificationAttachmentFieldsValue = buildNotificationAttachmentFieldsValue + " You need HA account with access to the Aries project."

  if ("${buildResult}" == "FAILURE") {
    buildNotificationAttachmentColor = "#FF0000" // Red
    buildNotificationAttachmentFieldsTitle = "Build Failed"
  } else if ("${buildResult}" == "UNSTABLE") {
    buildNotificationAttachmentColor = "#FFFF00" // Yellow
    buildNotificationAttachmentFieldsTitle = "Build Unstable"
  } else if ("${buildResult}" == "SUCCESS") {
    buildNotificationAttachmentFieldsTitle = "Build Successful"
    if ("${failedStages}" != "" || "${skippedStages}" != "") {
      buildNotificationAttachmentColor = "#BED48C" // Light Lime Green
    } else {
      buildNotificationAttachmentColor = "#00FF00" // Green
    }
  } else if ("${buildResult}" == "ABORTED") {
    buildNotificationAttachmentColor = "#808080" // Gray
    buildNotificationAttachmentFieldsTitle = "Build Aborted"
  } else {
    buildNotificationAttachmentColor = "#FFA500" // Orange
    buildNotificationAttachmentFieldsTitle = "Build Status Unknown"
  }

  if ("${failedStages}" != "") {
    buildNotificationAttachmentFieldsTitle = "${buildNotificationAttachmentFieldsTitle}, with failed stages ${failedStages}"
  }
  if ("${skippedStages}" != "") {
    buildNotificationAttachmentFieldsTitle = "${buildNotificationAttachmentFieldsTitle}, with skipped stages ${skippedStages}"
  }

  echo "buildNotificationText: ${buildNotificationText}"
  echo "buildNotificationAttachmentPretext: ${buildNotificationAttachmentPretext}"
  echo "buildNotificationAttachmentFieldsTitle: ${buildNotificationAttachmentFieldsTitle}"
  echo "buildNotificationAttachmentFieldsValue: ${buildNotificationAttachmentFieldsValue}"

  sh """
    set +x
    slackWebhookUrl=\$(oc get secret slack-aries-notification-webhook-secret -o jsonpath='{.data.text}' | base64 --decode)
    curl -X POST --data-urlencode \
    "payload={ \
      'channel': '${slackChannel}', \
      'username': '${slackUsername}', \
      'text': '${buildNotificationText}', \
      'attachments':[ \
        { \
          'fallback':'${buildNotificationAttachmentFallback}', \
          'pretext':'${buildNotificationAttachmentPretext}', \
          'color':'${buildNotificationAttachmentColor}', \
          'fields':[{ \
            'title':'${buildNotificationAttachmentFieldsTitle}', \
            'value':'${buildNotificationAttachmentFieldsValue}', \
            'short':false}] \
        } \
      ] \
    }" \
    --insecure \${slackWebhookUrl}
  """
  echo 'Done sending build notification to Slack channel'
}

pipeline {
  agent { label 'nodejs-agent' }

  stages {
    stage('Preamble') {
      steps {
        echo "Running " + PROJECT + " project on the " + CLUSTER + " cluster using the " + BUILD_CONFIG + " build configuration"
      }
    }

    stage('Post-\'Declarative Checkout\'') {
      when { expression { return !GIT_BRANCH_OVERRIDE } }
      steps {
        script {
          env.GIT_LOCAL_BRANCH = GIT_BRANCH.replaceAll("^origin/","")
          env.GIT_COMMIT_FINAL = GIT_COMMIT.take(8)
        }
      }
    }

    stage('Override Checkout') {
      when { expression { return GIT_BRANCH_OVERRIDE } }
      steps {
        script {
          env.GIT_LOCAL_BRANCH = GIT_BRANCH_OVERRIDE.replaceAll("^origin/","")
        }
        echo 'Checking out code'
        echo "Git Branch : ${GIT_LOCAL_BRANCH}"
        git (
          branch: "${GIT_LOCAL_BRANCH}",
          credentialsId: "${PROJECT}-${GIT_SOURCE_SECRET}",
          url: "${GIT_URL}"
        )
        script {
          env.GIT_COMMIT_FINAL = sh(script:"git rev-parse --short=8 HEAD", returnStdout: true).trim()
        }
        echo 'Checking out code done'
      }
    }

    stage('Prepare App Configs') {
      when { expression {
        boolean runStage = false
        if( "" != "${CONFIGS_GIT_BRANCH}" ) {
          runStage = true
        }
        else {
          env.APP_CONFIG_GIT_COMMIT_FINAL = ""
          echo "Configs Repo Git Commit Hash to configure the App with : ${APP_CONFIG_GIT_COMMIT_FINAL}"
        }
        return runStage
      } }

      steps {
        echo 'Preparing App Configs'
        sh 'mkdir -p configurations_repo'
        dir("configurations_repo") {
          git (
            branch: "${CONFIGS_GIT_BRANCH}",
            credentialsId: "${PROJECT}-${GIT_SOURCE_SECRET}",
            url: "${CONFIGS_GIT_URL}"
          )
          script {
            env.APP_CONFIG_GIT_COMMIT_FINAL = sh(script:"git rev-parse --short=8 HEAD", returnStdout: true).trim()
          }
        }
        echo "Configs Repo Git Commit Hash to configure the App with : ${APP_CONFIG_GIT_COMMIT_FINAL}"
        echo 'Done preparing App Configs'
      }
    }

    stage('Configure Environment') {
      steps {
        echo "Configuring build environment"
        script {
          if ( "develop" == "${GIT_LOCAL_BRANCH}" || "master" == "${GIT_LOCAL_BRANCH}" || "${GIT_LOCAL_BRANCH}".startsWith("integration/") || "${GIT_LOCAL_BRANCH}".startsWith("release/") || "${GIT_LOCAL_BRANCH}".startsWith("hotfix/") ) {
            pushImageToExternalRegistry = true
          }
          echo "pushImageToExternalRegistry: ${pushImageToExternalRegistry}"

          if ( "master" == "${GIT_LOCAL_BRANCH}" ) {
            promoteImageAsReleaseCandidate = true
            promoteImageAsLatest = true
          }
          echo "promoteImageAsReleaseCandidate: ${promoteImageAsReleaseCandidate}"
          echo "promoteImageAsLatest: ${promoteImageAsLatest}"

          env.GIT_COMMIT_MESSAGE = sh(script:"git --no-pager log --pretty=%s -n 1", returnStdout: true).trim()
          env.GIT_COMMIT_AUTHOR = sh(script:"git --no-pager log --pretty=%an -n 1", returnStdout: true).trim()
          echo "GIT_BRANCH: ${GIT_LOCAL_BRANCH}"
          echo "GIT_COMMIT: ${GIT_COMMIT_FINAL}"
          echo "GIT_COMMIT_MESSAGE: ${GIT_COMMIT_MESSAGE}"
          echo "GIT_COMMIT_AUTHOR: ${GIT_COMMIT_AUTHOR}"

          env.APP_VERSION = sh(script:"cd ${BUILD_CONTEXT_DIR} && npx project-version", returnStdout: true).trim()
          echo "APP_VERSION: ${APP_VERSION}"

          env.SNAPSHOT_VERSION = "${APP_VERSION}-SNAPSHOT-${GIT_COMMIT_FINAL}"
          env.RELEASE_CANDIDATE_VERSION = "${APP_VERSION}-RC-${IMAGE_TAG_DATE_AND_TIME}"
          env.RELEASE_VERSION = "${APP_VERSION}"
          echo "SNAPSHOT_VERSION: ${SNAPSHOT_VERSION}"
          echo "RELEASE_CANDIDATE_VERSION: ${RELEASE_CANDIDATE_VERSION}"
          echo "RELEASE_VERSION: ${RELEASE_VERSION}"
        }
        echo "Done configuring build environment"
      }
    }

    stage('Build') {
      steps {
        echo 'Building'
        sh '''
          cd ${BUILD_CONTEXT_DIR}
          npm ci
          npm run build
        '''
        echo 'Done building'
      }
    }

    stage('Unit Test'){
      steps {
        script {
          echo 'Unit tests'
          sh '''
            cd ${BUILD_CONTEXT_DIR}
            npm test
          '''
          echo 'Done running Unit Tests'
        }
      }
    }

    stage('TSLint'){
      // TODO
      when { expression {
        boolean runStage = false
        if( !runStage ) {
          skippedStages = "${skippedStages} -> TSLint"
        }
        return runStage
      } }

      steps {
        script {
          try {
            echo 'Running TSLint'
            sh '''
              cd ${BUILD_CONTEXT_DIR}
              npm run lint -- --format json > tslint-report.json
            '''
            echo 'Done running TSLinter'
          } catch (Exception e) {
            failedStages = "${failedStages} -> TSLint"
            // TODO do not fail the build until we can mark the stage as unstable via configuring buildResult and stageResult; We need Jenkins plugin "Pipeline: Basic Steps" 2.16 (May 14, 2019) and also possibly 2.18 for the bug fix for Declarative Pipeline: https://plugins.jenkins.io/workflow-basic-steps
            if( "${SUPPRESS_LINT_ERRORS}" != "true" ) {
              throw e;
            }
          }
        }
      }
    }

    stage('Sonar Report') {
      // TODO enable this stage once we get a project on the Anthem SonarQube server OR if we get a sandbox server
      when { expression {
        boolean runStage = false
        if( !runStage ) {
          skippedStages = "${skippedStages} -> Sonar Report"
        }
        return runStage
      } }

      steps {
        script {
          echo 'Sending coverage report to SonarQube'
          try {
            sh '''
              cd ${BUILD_CONTEXT_DIR}
              set +x
              sonarToken=$(oc get secret sonarqube-access-token-secret -o jsonpath='{.data.text}' | base64 --decode)
              npm run sonar-scanner -- \
                -Dsonar.host.url=https://sonarqube.anthem.com \
                -Dsonar.projectKey=aries_webapp \
                -Dsonar.login="\${sonarToken}"
            '''
          } catch (Exception e) {
            // TODO do not fail the build until we can mark the stage as unstable via configuring buildResult and stageResult; We need Jenkins plugin "Pipeline: Basic Steps" 2.16 (May 14, 2019) and also possibly 2.18 for the bug fix for Declarative Pipeline: https://plugins.jenkins.io/workflow-basic-steps
            failedStages = "${failedStages} -> Sonar Report"
          }
          echo 'Done sending coverage report to SonarQube'
        }
      }
    }

    stage('CVE Scan') {
      // TODO
      when { expression {
        boolean runStage = false
        if( !runStage ) {
          skippedStages = "${skippedStages} -> CVE Scan"
        }
        return runStage
      } }

      steps {
        script {
          try {
            echo 'Scanning for Common Vulnerability and Exposure'
            sh '''
              cd ${BUILD_CONTEXT_DIR}
              npm run cve
            '''
            echo 'Done with CVE Scan'
          } catch (Exception e) {
            failedStages = "${failedStages} -> CVE Scan"
            // TODO do not fail the build until we can mark the stage as unstable via configuring buildResult and stageResult; We need Jenkins plugin "Pipeline: Basic Steps" 2.16 (May 14, 2019) and also possibly 2.18 for the bug fix for Declarative Pipeline: https://plugins.jenkins.io/workflow-basic-steps
            if( "${SUPPRESS_CVE_FAILURES}" != "true" ) {
              throw e;
            }
          }
        }
      }
    }

    stage('Veracode Scan') {
      // TODO enable this stage possibly with PIA-39746 if Veracode infra is ready for CI/CD
      when { expression {
        boolean runStage = false
        if( !runStage ) {
          skippedStages = "${skippedStages} -> Veracode Scan"
        }
        return runStage
      } }

      steps {
        script {
          try {
            echo 'Performing Veracode Scan of the build artifact'
//             sh '''
//               set +x
//             '''
            echo 'Done performing Veracode Scan of the build artifact'
          } catch (Exception e) {
            // TODO do not fail the build until we can mark the stage as unstable via configuring buildResult and stageResult; We need Jenkins plugin "Pipeline: Basic Steps" 2.16 (May 14, 2019) and also possibly 2.18 for the bug fix for Declarative Pipeline: https://plugins.jenkins.io/workflow-basic-steps
            failedStages = "${failedStages} -> Veracode Scan"
          }
        }
      }
    }

    stage('Build Image'){
      steps {
        echo 'Starting container build'
        sh '''
          cd ${BUILD_CONTEXT_DIR}
          rm -rf runtime && mkdir -p runtime
          for t in \$(ls "dist" | tr ";" "\\n"); do
            cp -rfv ./dist/\$t runtime/ 2> /dev/null || echo "No \$t files/directories"
          done
          mkdir -p runtime/node_modules
          for t in \$(ls "node_modules" | tr ";" "\\n"); do
            cp -rfv ./node_modules/\$t runtime/node_modules/ 2> /dev/null || echo "No \$t files/directories"
          done
          cp -rfv ./openshift/Dockerfile runtime/
          cp -rfv ./openshift/docker-entrypoint.sh runtime/

          oc start-build ${APP_NAME}-docker --from-dir="runtime" --follow --wait

          exit_status=$?
          if [ $exit_status -eq 1 ]; then
            exit 1
          fi
        '''
        echo 'Done building Container'
      }
    }

    stage('Twistlock Scan') {
      // TODO enable this stage possibly with PIA-40908 if Twistlock infra is ready for CI/CD
      when { expression {
        boolean runStage = false
        if( !runStage ) {
          skippedStages = "${skippedStages} -> Twistlock Scan"
        }
        return runStage
      } }

      steps {
        script {
          try {
            echo 'Performing Twistlock Scan of the container image'
//             sh '''
//               set +x
//             '''
            echo 'Done performing Twistlock Scan of the container image'
          } catch (Exception e) {
            // TODO do not fail the build until we can mark the stage as unstable via configuring buildResult and stageResult; We need Jenkins plugin "Pipeline: Basic Steps" 2.16 (May 14, 2019) and also possibly 2.18 for the bug fix for Declarative Pipeline: https://plugins.jenkins.io/workflow-basic-steps
            failedStages = "${failedStages} -> Twistlock Scan"
          }
        }
      }
    }

    stage('Tag Image to Snapshot') {
      steps {
        script {
          echo 'Tagging the image to a snapshot version'
          sh "oc tag ${APP_NAME}:build_candidate ${APP_NAME}:${SNAPSHOT_VERSION}"
          sh "oc tag ${APP_NAME}:build_candidate -d"
          echo 'Done tagging the image to a snapshot version'
        }
      }
    }

    stage('Tag Image to latest') {
      steps {
        script {
          echo 'Tagging the image to \'latest\''
          sh "oc tag ${APP_NAME}:${SNAPSHOT_VERSION} ${APP_NAME}:latest"
          echo 'Done tagging the image to \'latest\''
        }
      }
    }

    stage('Deploy') {
      steps {
        script {
          echo 'Deploying the app'
          openshift.withCluster() {
            openshift.withProject() {
              sh "oc set env dc/${APP_NAME} SPBC_CLOUD_CONFIG_LABEL=${APP_CONFIG_GIT_COMMIT_FINAL}"
              sh "oc rollout latest dc/${APP_NAME}"
              def dc = openshift.selector('dc', "${APP_NAME}")
              timeout (time: 5, unit: 'MINUTES') {
                dc.related('pods').untilEach(1) {
                  return (it.object().status.phase == "Running")
                }
              }
            }
          }
          echo 'Done deploying the app'
        }
      }
    }

    stage('Verify Deployment') {
      steps {
        script {
          echo 'Verifying deployment'
          openshift.withCluster() {
            openshift.withProject() {
              def dc = openshift.selector('dc', "${APP_NAME}")
              timeout (time: 5, unit: 'MINUTES') {
                // this will wait until the desired replicas are available
                dc.rollout().status()
              }
            }
          }
          echo 'Done verifying deployment'
        }
      }
    }

    // TODO E2E

    stage('PR Image to NP2 (Quay)') {
      when { expression { return pushImageToExternalRegistry } }

      steps {
        script {
          echo 'Promoting Images to Non-Prod Quay (NP2)'

          echo "Promoting the snapshot image to Quay NP2"
          openshift.withCluster() {
            openshift.withProject() {
              def bc = openshift.selector("bc", "aries-image-promote-ocp-to-quay.np2")
              bc.startBuild("--wait", "--env", "SOURCE_IMAGE_REPOSITORY=${APP_NAME}", "--env", "DESTINATION_IMAGE_REPOSITORY=${APP_NAME}","--env", "SOURCE_IMAGE_TAG=${SNAPSHOT_VERSION}", "--env", "DESTINATION_IMAGE_TAG=${SNAPSHOT_VERSION}")
            }
          }

          if( promoteImageAsReleaseCandidate ) {
            echo "Promoting the snapshot image to Quay NP2 and tagging it as a Release Candidate"
            openshift.withCluster() {
              openshift.withProject() {
                def bc = openshift.selector("bc", "aries-image-promote-ocp-to-quay.np2")
                bc.startBuild("--wait", "--env", "SOURCE_IMAGE_REPOSITORY=${APP_NAME}", "--env", "DESTINATION_IMAGE_REPOSITORY=${APP_NAME}", "--env","SOURCE_IMAGE_TAG=${SNAPSHOT_VERSION}", "--env", "DESTINATION_IMAGE_TAG=${RELEASE_CANDIDATE_VERSION}")
              }
            }
          }

          if( promoteImageAsLatest ) {
            echo "Promoting the snapshot image to Quay NP2 and tagging it as the latest"
            openshift.withCluster() {
              openshift.withProject() {
                def bc = openshift.selector("bc", "aries-image-promote-ocp-to-quay.np2")
                bc.startBuild("--wait", "--env", "SOURCE_IMAGE_REPOSITORY=${APP_NAME}", "--env", "DESTINATION_IMAGE_REPOSITORY=${APP_NAME}", "--env","SOURCE_IMAGE_TAG=${SNAPSHOT_VERSION}", "--env", "DESTINATION_IMAGE_TAG=latest")
              }
            }
          }

          echo 'Done Promoting Images to Non-Prod Quay (NP2)'
        }
      }
    }

    stage('Cleanup Tags: Snapshot') {
      steps {
        script {
          echo 'Cleanup no longer necessary snapshot tag'
          sh "oc tag ${APP_NAME}:${SNAPSHOT_VERSION} -d"
          echo 'Done cleaning up no longer necessary snapshot tag'
        }
      }
    }

  } // stages

  post {
    always {
      script {
        echo 'Sending build notification to Slack channel aries-notifications'

        projectName = "${PROJECT}"
        pipelineName = "${APP_NAME}"
        startedDateTime = "${NOTIFICATION_DATE_AND_TIME}"
        buildResult = currentBuild.currentResult
        failedStages = "${failedStages}"
        skippedStages = "${skippedStages}"
        buildDuration = currentBuild.durationString
        gitBranch = "${GIT_LOCAL_BRANCH}"
        gitCommit = "${GIT_COMMIT_FINAL}"
        gitCommitMessage = "${GIT_COMMIT_MESSAGE}"
        gitAuthor = "${GIT_COMMIT_AUTHOR}"

        notifySlack(projectName, pipelineName, startedDateTime, buildResult, failedStages, skippedStages, buildDuration, gitBranch, gitCommit, gitCommitMessage, gitAuthor)
      }
    }
  }

} // pipeline
